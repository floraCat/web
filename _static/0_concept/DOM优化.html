<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>DOM优化</title>
</head>
<body>

<xmp style=" font-family:黑体; font-size:10px; font-style:italic; color:#aaa;">来源：妙味课堂->JS原创视频教程-知识点类-1->DOM优化,http://www.miaov.com/2013/miaovideo/miaovideo.html</xmp>

<xmp style=" font-family:微软雅黑; font-size:14px;">


    JS：由 'DOM' & 'ECMA' & 'BOM' 组成
    ------------------------------------

	DOM：用于操作XML和HTML文档的应用程序
	     包括：-Dom节点
	           -Dom树
	           -Dom API
	------------------------------------


	/***优化:***/
	*************

	DOM与JS独立操作：
	------------------------------------
	-> 浏览器操作DOM与操作JS是独立实现的
	-> 操作DOM与JS之间的交互(切换)是会消耗性能的
	*1-1 尽可能减少两者之间的频繁交互
	*1-2 innerHTML与DOM方法的对比


	减少DOM操作：
	------------------------------------
	*2-1 节点克隆 - cloneNode
	*2-2 访问元素集合 - 尽量用局部变量
	*2-3 元素节点 - 尽量用只获取元素的节点方法
	*2-4 选择器API - 利用querySelector,querySelectorAll


	减少重排&重绘：
	------------------------------------
	-> 重排：改变页面的内容
	-> 重绘：浏览器显示内容
	*3-1 添加顺序 - 尽量在appendChild前添加操作
	*3-2 合并dom操作 - 利用cssText
	*3-3 缓存布局信息
	*3-4 文档碎片 - createDocumentFragment();


	其他：
	------------------------------------
	-> Dom与事件 - 事件委托
	-> Dom与前端模板 - 能更好地对逻辑和视图分离，MVC架构的基础



	测试实例：
	------------------------------------
	<html>
		<div id="div1"></div>
	</html>
	window.onload=function(){
		var oDiv=document.getElementById("div1");
		console.time("hi");
		——1-1——————————————————————————————————————————————————————————
		for(var i=0;i < 5000;i++){
			oDiv.innerHTML+='<li>i</li>'; //情况一：JS循环一次就操作一次DOM
		}
		——   ——————————————————————————————————————————————————————————
		var str='';
		for(var i=0;i < 5000;i++){
			str+='<li>li</li>';
		}
		oDiv.innerHTML=str; //情况二：JS每次循环先存起来，再一次性操作DOM，比上一例要快
		——1-2——————————————————————————————————————————————————————————
		for(var i=0;i < 5000;i++){
			var oLi=document.createElement("li");
			oLi.innerHTML="li";
			oDiv.appendChild(oLi); //webkit浏览器中比用innerHTML方法快，其他浏览器相反
		}
		//结论：webkit类型浏览器(chrome)的DOM方法比innerHTML性能要好
		——2-1——————————————————————————————————————————————————————————
		var oLi=document.createElement("li");
		oLi.innerHTML="li";
		for(var i=0;i < 5000;i++){
			var newLi=oLi.cloneNode(true); //节点克隆比重新创建一个节点性能好，减少了DOM操作
			oUl.appendChild(newLi);
		}
		——2-2——————————————————————————————————————————————————————————
		for(var i=0;i < oLi.length; i++){ //每次循环都要重新操作DOM来获取oLi.length集合
			aLi[i].innerHTML="li";
		}
		——   ——————————————————————————————————————————————————————————
		var len=oLi.length; //存储到一个变量里，比上一例要快
		for(var i=0; i < len; i++){...}
		//同类情况：
			var doc=document;
			var oLi=doc.getElementById();
			var oUl=doc.getElementById();
			var oOl=doc.getElementById();
		——2-3——————————————————————————————————————————————————————————
		childNodes -> 元素节点 + 文本节点
		children -> 元素节点
		//用childNodes 代替 children 来提高性能
		//同理用firstElementChild 代替 firstChild 来提高性能
		——2-4——————————————————————————————————————————————————————————
		var oUl=document.getElementById("ul");
		var oLi=oUl.getElementById("li");
		//用下例的操作一次DOM来获取代替上面的要操作两次DOM来提高性能
		var aLi=document.querySelectorAll("#ul li"); //ie8以下的不支持
		——3-1——————————————————————————————————————————————————————————
		for(var i=0;i < 5000;i++){
			var oLi=document.createElement("li");
			oDiv.appendChild(oLi);
			oLi.innerHTML="li"; //此句应放到appendChild上面从而减少重排重绘操作
		}
		——3-2——————————————————————————————————————————————————————————
		oLi.style.width='100px';
		oLi.style.background='red';
		//用下例的合并操作代替上面的分开操作来提高性能
		oLi.style.cssText='width:100px;background=red';
		——3-3——————————————————————————————————————————————————————————
		setInterval(function(){
			oDiv.style.left=oDiv.offsetLeft + "px"; //每次都要操作一次DOM
			oDiv.style.left=oDiv.offsetTop + "px";
		},30);
		——   ——————————————————————————————————————————————————————————
		var L=oDiv.offsetLeft;  //把布局信息缓存起来再操作DOM,比上一例性能要好
		var T=oDiv.offsetTop;
		setInterval(function(){
			L++;
			T++;
			oDiv.style.left= L + "px";
			oDiv.style.left= T + "px";
		},30);
		——3-4——————————————————————————————————————————————————————————
		var oFrag=document.createDocumentFragment();
		for(var i=0;i < 5000;i++){
			var oLi=document.createElement("li");
			oFrag.appendChild(oLi); //把文档碎片都先存储到oFrag内
		}
		oDiv.appendChild(oFrag); //再一次性操作DOM，比例2-1性能好
		————————————————————————————————————————————————————————————
		console.timeEnd("hi");
	}
	
	</xmp>


</body>
</html>