<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>requirejs</title>
</head>
<body>

<xmp style=" font-family:黑体; font-size:10px; font-style:italic; color:#aaa;">来源：http://www.tuicool.com/articles/bu6Zbi</xmp>

<xmp style=" font-family:微软雅黑; font-size:14px;">

	用requirejs的好处：
	----------------------------------------------
	* 实现JS文件的异步加载，避免网页被堵塞
	* 管理模块之间的依赖性，便于代码的编写和维护



	实例目录：
	----------------------------------------------
	test
		js
			app
				a.js
				b.js
			lib
				jquery1.7.js
				jquery1.9.js
			app.js
		index.html



	安装：
	----------------------------------------------
	<script src="js/require.js" defer async="true" data-main="js/app.js"></script>
	//Async属性表明文件需要异步加载，IE不支持这个属性，只支持defer
	//data-main 这个属性来加载初始化的JS文件



	定义模块：
	----------------------------------------------
	//如a.js如下:
	define(['依赖文件1','依赖文件2'],function(){
		var add = function(x,y) {
			return x + y;
		};
		return {
			add : add
		}
	});
	//没有依赖项'[]'可空，也可省略



	调用：
	----------------------------------------------
	//如app.js如下:
	require(['app/b'], function (b){
		console.log(b.add(1,1));
	});
	______________________________________________

	//带错误回调：
	require(['app/b'],function(b){
		alert(b);
	},function(err){
		alert(err);
	});
	//载入错误时，不能执行第一个回调，转而执行第二个回调
	______________________________________________

	//载入失败回调中可以使用undef函数移除模块的注册
	require(['b'],function($){
		//Do something with $ here
	},function(err){
		var failedId=err.requireModules &&  err.requireModules[0]; //获得模块名
		if(failedId==='b'){
			requirejs.undef(failedId);
		}
	})





	/***配置:***/
	*************

	baseUrl：
	----------------------------------------------
	//基准目录 （没配置时由data-main指定）


	paths：
	----------------------------------------------
	//映射不直接放在baseUrl下的文件目录，起始位置相对于baseUrl


	shim：
	----------------------------------------------
	//为没有使用define定义的模块来声明依赖关系


	map：
	----------------------------------------------
	//解决同一模块不同版本的问题


	config：
	----------------------------------------------
	//将配置信息传给一个模块



	实例：
	----------------------------------------------
	requierjs.config({
		baseUrl:'js/app',
		paths:{
			lib:'../lib'
		},
		shim:{
			'a':['lib/jquery1.7']
		},
		map:{
			a:{
				'jquery':'lib/jquery1.7.js'
			},
			b:{
				'jquery':'lib/jquery1.9.js'
			}
		},
		config:{
			c:{
				size:'large'
			},
			d:{
				color:'red'
			}
		}
	});





	/***AMD模块规范:***/
	********************

	第一种：
	----------------------------------------------
	define(function() { 
		return { 
			mix: function(source, target) {...} 
		}; 
	});


	第二种：
	----------------------------------------------
	//有依赖项
	define(['data', 'ui'], function(data, ui) { 
		// init here 
	});


	第三种：
	----------------------------------------------
	//直接一个对象
	define({ 
		data: [], 
		ui: [] 
	});


	第四种：
	----------------------------------------------
	//具名模块
	define('index', ['data','base'], function(data, base) { 
		// todo 
	});


	第五种：
	----------------------------------------------
	//包装模块
	define(function(require, exports, module) { 
		var base = require('base'); 
		exports.show = function() { 
			// todo with module base 
		}  
	});
	//使用require获取模块，使用exports或者module.exports导出API

	_________________________________________________

	对于第四种写法 具名模块写法我们并不推荐的，因为不书写模块名我们一样可以调用，且在合并代码的时候，我们也可以根据代码自动生成模块名，如果我们现在写死了模块名，当某个时候，b.js我要移动到其他目录时候，JS也要跟着改，所以代码维护方面不好，所以不建议书写模块名。
	对于第五种写法，requireJS中也是支持的，通过内部调用require来处理依赖模块


</xmp>

</body>
</html>