<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>类</title>
</head>
<body>

<xmp style=" font-family:微软雅黑; font-size:14px;">

定义类：
----------

(function($){
    ------------------------------------
    //构造函数
    function AAA(){
        ------------------------------------
        var prop_1="私有属性";
        function fun_1(){
            console.log("fun_1-[私有方法]");
        }
        ------------------------------------
    	this.prop_2="公有属性";
        this.fun_2=function(){
            console.log("fun_2-[特权方法]");
        } 
        ------------------------------------
    }
    ------------------------------------
    var AAA2={
        prop_2a:"对象字面量的共有属性",
        fun_2a:function(){
            console.log("fun_2a-[对象字面量的特权方法]");
        }
    }
    ------------------------------------
    AAA.prop_3="静态属性";
    AAA.fun_3=function(){
        console.log("fun_3-[静态方法/工具函数]");
    }
    ------------------------------------
    AAA={
        prop_3a:"对象字面量的静态属性",
        fun_3a:function(){
            console.log("fun_3a-[对象字面量的静态方法/工具函数]");
        }
    }
    ------------------------------------
    //原型
    AAA.prototype.prop_4="原型属性";
    AAA.prototype.fun_4=function(){
        console.log("fun_4-[原型方法/公有方法]");
        this.fun_2(); //共有方法的调用
    }
    ------------------------------------
    //原型重写
    AAA.prototype={
        prop_4a:"原型重写的原型属性",
        fun_4a:function(){
            console.log("fun_4a-[原型重写的原型方法/公有方法]");
        }
    }
    ------------------------------------
    var x = new AAA(); //实例化 x
    
    x.prop_5="实例属性";
    x.fun_5=function(){
        console.log("fun_5-[实例方法]");
    }
    ------------------------------------
    var y = new AAA(); //实例化 y
    ------------------------------------
})(jQuery);


-----------------------

# 类相关
    + ————
        --构造函数名字头个字母大写；
        --静态方法是在处理性质上相似的一些公用函数，抽象出来，绑定到一个类下来进行管理。js中可以在一个构造器上加它自己的属性方法来作为静态方法和静态属性。
        --实例方法和静态类似，也是同一批操作的集合，不过实例方法会有相同的处理重心this，也就是说，实例方法是当前对象this的某个动作或行为，特殊强调当前的上下文this
        --静态方法更像是工具集，是通用功能的抽取，实例方法更强调上下文的服务者，是一类对象特征的抽象

# 属性
    + 相关
        --静态属性是全局的，原型属性是实例公有的，实例属性是各个实例所独有的

# 特权方法和公有方法：
    * 相同点：
        --都可以在构造函数外部公开访问（实例都可以访问）
        --都可以访问公有属性 
    * 不同点
        --每个实例都拥有一份特权方法的副本（除在单例中使用外，需要考虑内存），而公有方法为所有实例共享同一个引用地址
            console.log(x.fun_2 === y.fun_2); //false - 两实例的特权方法的引用不相同, 说明在对象实例化的时特权方法被重新创建 
            console.log(x.fun_4 === y.fun_4); //true
        --特权方法可以访问私有属性和私有方法；公有方法不能；
    + 其他
        --公有方法即原型方法
        --特权方法作为构造函数的接口，公有方法可以通过特权方法访问私有属性和方法


__________________________________________________________________



当代码var zhang = new Person("ZhangSan", "man")执行时，其内部做了如下几件事情：

* 创建一个空白对象（new Object()）。
* 拷贝Person.prototype中的属性（键值对）到这个空对象中（我们前面提到，内部实现时不是拷贝而是一个隐藏的链接）。
* 将这个对象通过this关键字传递到构造函数中并执行构造函数。
* 将这个对象赋值给变量zhang。


</xmp>

</body>
</html>